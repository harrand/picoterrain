renderer_data ::= struct
{
	camera_buffer : gpu_resource;
	terrain_buffer : gpu_resource;

	shader : gpu_shader;
	pass : gpu_pass;
	graph : gpu_graph;
};
renderer : renderer_data mut := zero;

render_setup ::= func(-> v0)
{
	// setup gpuren
	gpu_init(gpu_appinfo
	{
		.name := "Red Nightmare";
		.ver_maj := 0;
		.ver_min := 1;
	});

	// tell it which hardware to use
	hardware_count ::= gpu_hardware_count();
	hardware_list : gpu_hardware mut? := arena_alloc(global_arena, __sizeof(gpu_hardware) * hardware_count);
	gpu_query_hardware(hardware_list # 0, hardware_count, global_arena);
	hardware_idx ::= gpu_hardware_select(hardware_list, hardware_count, gpu_default_hardware_score);
	gpu_use_hardware(deref(hardware_list # hardware_idx), gpu_wsi
	{
		.type := gpu_wsi_type.window;
		.window := gpu_wsi_window
		{
			.handle := main_window@s64@_;
			.get_native := impl_window_get_native;
			.get_dimensions := impl_window_get_dimensions;
		};
	});
	gpu_set_present_mode(gpu_present_mode.vsync);	

	// create the renderer
	// 1: shader
	vtx ::= __embed("build/vtx.spv");
	frg ::= __embed("build/frg.spv");
	renderer.shader = gpu_create_graphics_shader(vtx.data, vtx.size, frg.data, frg.size, global_arena);
	
	// 2: resources
	terrain_buffer_result ::= gpu_create_buffer(gpu_resource_info
	{
		.data := zero;
		.data_size := __sizeof(terrain_data);
		.flags := gpu_resource_flag.zero_memory;
		.buffer_flags := gpu_buffer_flag.dynamic;
		.name := "terrain buffer";
	}, global_arena);
	renderer.terrain_buffer = (terrain_buffer_result.res);

	camera_buffer_result ::= gpu_create_buffer(gpu_resource_info
	{
		.data := zero;
		.data_size := __sizeof(camera_data);
		.flags := gpu_resource_flag.zero_memory;
		.buffer_flags := gpu_buffer_flag.dynamic;
		.name := "camera buffer";
	}, global_arena);
	renderer.camera_buffer = (camera_buffer_result.res);

	// 3: pass
	colour_targets ::= gpu_resource[1]{gpu_resource.window_resource;};
	resources ::= gpu_resource[2]{renderer.terrain_buffer; renderer.camera_buffer;};

	main_pass_result ::= gpu_create_pass(gpu_pass_info
	{
		.graphics := gpu_graphics_state
		{
			.primitive := gpu_primitive.triangle;
			.clear_colour := f32[4]{0.0; 0.0; 0.0; 1.0;};
			.scissor := zero;
			.colour_targets_data := colour_targets # 0;
			.colour_targets_count := __sizeof(colour_targets) / __sizeof(deref(colour_targets # 0));
			.depth_target := gpu_resource.window_resource;
			.index_buffer := gpu_resource.invalid;
			.draw_buffer := gpu_resource.invalid;
			.culling := gpu_cull.none;	
			.static_prim_count := 2 * plane_subdivide_x * plane_subdivide_y;
		};
		.shader := renderer.shader;
		.resources_data := resources # 0;
		.resources_count := __sizeof(resources) / __sizeof(deref(resources # 0));
		.name := "Terrain Render Pass";
	}, global_arena, frame_arena);
	renderer.pass = (main_pass_result.res);

	// 4: graph
	renderer.graph = gpu_create_graph(gpu_graph_info
	{
		.name := "Picoterrain Render";
		.flags := gpu_graph_flag.present;
	}, global_arena);
	gpu_graph_add_pass(renderer.graph, renderer.pass, zero, zero, global_arena);
};

render_clear_colour ::= func(col : f32[4] -> v0)
{
	gpu_pass_set_clear_colour(renderer.pass, col);
};

render ::= func(-> v0)
{
	gpu_execute(renderer.graph, global_arena, frame_arena);
};

impl_window_get_native ::= func(handle : u64 -> u64)
{
	return window_native(handle@s64@window);
};

impl_window_get_dimensions ::= func(handle : u64 -> u32[2])
{
	return window_dimensions(handle@s64@_);
};

