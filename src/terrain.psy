terrain ::= func(-> terrain_data mut?)
{
	return gpu_resource_pointer(renderer.terrain_buffer).ptr@_;
};

terrain_randomise ::= func(seed : s64 -> v0)
{
	srand(seed);
	deref(terrain()) = terrain_data
	{
		.seed := (rand() % 10000)@_;
		// dont make this too high
		// between -0.2 and 0.2 lets say
		.sea_level := randf() * 0.01;
		.sea_colour := f32[3]{(randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5;};
		.sea_banding := randf() * 0.5;
		.base_colour := f32[3]{(randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5;};
		.y_scale := 4 + (rand() % 32)@_;
		.roughness := 2 + (rand() % 32)@_;
	};
	sea ::= terrain()->sea_colour;
	render_clear_colour(f32[4]{deref(sea # 0); deref(sea # 1); deref(sea # 2); 1.0;});
};

terrain_data ::= struct
{
	seed : u32;
	// at what height should we be the sea_colour? also everything is clamped to sea_level
	sea_level : f32;
	// what colour is the sea?
	sea_colour : f32[3];
	// between (sea_level + sea_banding) and (sea_level), the colour lerps towards sea_colour
	// is sand called sand because its between the sea and the land?
	sea_banding : f32;
	base_colour : f32[3];

	y_scale : f32;
	roughness : f32;
};
