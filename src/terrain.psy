terrain ::= func(-> terrain_data mut?)
{
	return gpu_resource_pointer(renderer.terrain_buffer).ptr@_;
};

get_random_terrain ::= func(-> terrain_data)
{
	return terrain_data
	{
		.seed := (rand() % 10000)@_;
		// dont make this too high
		// between -0.2 and 0.2 lets say
		.sea_level := 0.1 + (randf() * 0.2);
		.sea_colour := f32[3]{(randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5;};
		.sea_banding := randf() * 0.1;
		.sky_level := (((randf() + 1.0) * 25.0) + 2)@_;
		.sky_colour := f32[3]{(randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5;};
		.sky_banding := (((randf() + 1.0) * 25.0) + (randf() + 1.0))@_;
		.base_colour := f32[3]{(randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5;};
		.xz_scale := (2 + (rand() % 16))@_;
		.y_scale := 4 + (rand() % 32)@_;
		.roughness := 2 + (rand() % 1024)@_;
	};
};

terrain_randomise ::= func(seed : s64 -> v0)
{
	srand(seed);
	deref(terrain()) = get_random_terrain();
	match_clear_colour_to_terrain();
	camera()->t = f32[3]{0.0; terrain()->sky_level; 0.0;};
};

match_clear_colour_to_terrain ::= func(-> v0)
{
	sea ::= terrain()->sea_colour;
	render_clear_colour(f32[4]{deref(sea # 0); deref(sea # 1); deref(sea # 2); 1.0;});
};

terrain_data ::= struct
{
	seed : u32;
	// at what height should we be the sea_colour? also everything is clamped to sea_level
	sea_level : f32;
	// what colour is the sea?
	sea_colour : f32[3];
	// between (sea_level + sea_banding) and (sea_level), the colour lerps towards sea_colour
	// is sand called sand because its between the sea and the land?
	sea_banding : f32;

	sky_level : f32;
	sky_colour : f32[3];
	sky_banding : f32;

	base_colour : f32[3];

	xz_scale : f32;
	y_scale : f32;
	roughness : f32;
};
