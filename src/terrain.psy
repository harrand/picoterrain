terrain ::= func(-> terrain_data mut?)
{
	return gpu_resource_pointer(renderer.terrain_buffer).ptr@_;
};

get_random_terrain ::= func(-> terrain_data)
{
	return terrain_data
	{
		.seed := (rand() % 10000)@_;
		// dont make this too high
		// between -0.2 and 0.2 lets say
		.sea_level := 0.1 + (randf() * 0.2);
		.sea_colour := f32[3]{(randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5;};
		.sea_banding := randf() * 0.1;
		.sky_level := (((randf() + 1.0) * 25.0) + 2)@_;
		.sky_colour := f32[3]{(randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5;};
		.sky_banding := (((randf() + 1.0) * 25.0) + (randf() + 1.0))@_;
		.base_colour := f32[3]{(randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5; (randf() + 1.0) * 0.5;};
		.xz_scale := (2 + (rand() % 16))@_;
		.y_scale := 4 + (rand() % 32)@_;
		.roughness := 2 + (rand() % 1024)@_;
	};
};

randomise_time_begin : s64 mut := zero;
is_randomising : bool mut := false;
old_terrain : terrain_data mut := zero;
new_terrain : terrain_data mut := zero;

randomise_duration ::= 5 * 1000000;

terrain_randomise ::= func(seed : s64 -> v0)
{
	if(is_randomising)
	{
		return;
	}
	is_randomising = true;
	old_terrain = deref terrain();
	srand(seed);
	new_terrain = get_random_terrain();
	randomise_time_begin = time_static();
	//srand(seed);
	//deref(terrain()) = get_random_terrain();
	//match_clear_colour_to_terrain();
	//camera()->t = f32[3]{0.0; terrain()->sky_level; 0.0;};
};

update_terrain ::= func(-> v0)
{
	if(!is_randomising)
	{
		return;
	}
	diff ::= time_static() - randomise_time_begin;
	factor ::= diff@f32 / randomise_duration;
	set_terrain(terrain_coserp(old_terrain, new_terrain, factor));
	if(factor >= 1.0)
	{
		is_randomising = false;
	}
};

set_terrain ::= func(t : terrain_data -> v0)
{
	deref(terrain()) = t;
	match_clear_colour_to_terrain();
};

match_clear_colour_to_terrain ::= func(-> v0)
{
	sea ::= terrain()->sea_colour;
	render_clear_colour(f32[4]{deref(sea # 0); deref(sea # 1); deref(sea # 2); 1.0;});
};

terrain_lerp ::= func(from : terrain_data, to : terrain_data, factor : f32 -> terrain_data)
{
	return terrain_data
	{
		.seed := from.seed;
		.sea_level := flerp(from.sea_level, to.sea_level, factor);
		.sea_colour := vec3lerp(from.sea_colour, to.sea_colour, factor);
		.sea_banding := flerp(from.sea_banding, to.sea_banding, factor);
		.sky_level := flerp(from.sky_level, to.sky_level, factor);
		.sky_colour := vec3lerp(from.sky_colour, to.sky_colour, factor);
		.sky_banding := flerp(from.sky_banding, to.sky_banding, factor);
		.base_colour := vec3lerp(from.base_colour, to.base_colour, factor);
		.xz_scale := flerp(from.xz_scale, to.xz_scale, factor);
		.y_scale := flerp(from.y_scale, to.y_scale, factor);
		.roughness := flerp(from.roughness, to.roughness, factor);
	};
};

terrain_coserp ::= func(from : terrain_data, to : terrain_data, factor : f32 -> terrain_data)
{
	return terrain_data
	{
		.seed := from.seed;
		.sea_level := fcoserp(from.sea_level, to.sea_level, factor);
		.sea_colour := vec3coserp(from.sea_colour, to.sea_colour, factor);
		.sea_banding := fcoserp(from.sea_banding, to.sea_banding, factor);
		.sky_level := fcoserp(from.sky_level, to.sky_level, factor);
		.sky_colour := vec3coserp(from.sky_colour, to.sky_colour, factor);
		.sky_banding := fcoserp(from.sky_banding, to.sky_banding, factor);
		.base_colour := vec3coserp(from.base_colour, to.base_colour, factor);
		.xz_scale := fcoserp(from.xz_scale, to.xz_scale, factor);
		.y_scale := fcoserp(from.y_scale, to.y_scale, factor);
		.roughness := fcoserp(from.roughness, to.roughness, factor);
	};
};

terrain_data ::= struct
{
	seed : u32;
	// at what height should we be the sea_colour? also everything is clamped to sea_level
	sea_level : f32;
	// what colour is the sea?
	sea_colour : f32[3];
	// between (sea_level + sea_banding) and (sea_level), the colour lerps towards sea_colour
	// is sand called sand because its between the sea and the land?
	sea_banding : f32;

	sky_level : f32;
	sky_colour : f32[3];
	sky_banding : f32;

	base_colour : f32[3];

	xz_scale : f32;
	y_scale : f32;
	roughness : f32;
};
