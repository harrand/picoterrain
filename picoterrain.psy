== default ==
{
	warning("no build config specified - defaulting to debug");
	debug();
}

== debug ==
{
	set_optimization(0);
	debug_symbols(true);
	base();
}

== release ==
{
	set_optimization(3);
	debug_symbols(false);
	base();
}

== base ==
{
	set_executable("picoterrain");
	add_build_file("gpuren/gpu.psy", "default");
	add_build_file("psystdlib/stdlib.psy", "default");
	add_source_directory("src");
	//debug_symbols(true);

	prebuild_command("glslc src/shaders/vtx.glsl -o build/vtx.spv");
	prebuild_command("glslc src/shaders/frg.glsl -o build/frg.spv");

	static if(_win32)
	{
		add_link_library("User32.lib");
		add_link_library("Shell32.lib");
		add_link_library("Gdi32.lib");
		add_link_library("Dwmapi.lib");
	}
	else
	{
		error("picoterrain is not supported on linux");
	}
}

main_window : window mut;

global_arena_value : arena mut := zero;
global_arena : arena mut? mut := zero;
frame_arena_value : arena mut := zero;
frame_arena : arena mut? mut := zero;

plane_subdivide_x ::= 128;
plane_subdivide_y ::= 128;

main ::= func(args : program_args? -> s32)
{
	seed : s64 mut := time_static() % 1234;
	if(args->argc > 1)
	{
		seed = parse_int(deref(args->argv # 1));
	}

	begin_arenas();
	defer end_arenas();
	main_window = window_open(800, 600, "picoterrain", window_flag.maximised | window_flag.bare, global_arena);

	render_setup();
	render_clear_colour(f32[4]{0.3; 0.4; 0.9; 1.0;});
	// birds eye view
	//camera()->t = f32[3]{0.0; 25.0; 0.0;};
	//camera()->r = euler2quat(f32[3]{math_pi * -0.5; 0.0; 0.0;});

	// normal view
	camera()->t = f32[3]{0.0; 6.0; 0.0;};
	camera()->r = euler2quat(zero);

	srand(seed);
	set_terrain(get_random_terrain());
	camera()->t = f32[3]{0.0; terrain()->sky_level; 0.0;};

	while(window_is_open(main_window))
	{
		control();
		arena_clear(frame_arena);
		render();
		update_terrain();
		update_windows();
	}
	return 0;
};

begin_arenas ::= func(-> v0)
{
	global_arena_value = arena_create_virtual_reserve(arena_default_reserve, 1024 * 1024);
	global_arena = ref global_arena_value;	

	frame_arena_value = arena_create_virtual_reserve(arena_default_reserve, 1024 * 1024);
	frame_arena = ref frame_arena_value;	
};

end_arenas ::= func(-> v0)
{
	putzstr("global arena size: ");
	putuint(global_arena->cur);
	putzstr("B");
	putchar(10);
	arena_destroy(global_arena);

	arena_destroy(frame_arena);
};

isdigit ::= func(ch : u8 -> bool)
{
	if(ch >= '0')
	{
		if(ch <= '9')
		{
			return true;
		}
	}
	return false;
};

parse_int ::= func(src : u8? -> s64)
{
	src_begin : u8? mut := src;
	len ::= zstrlen(src);
	begin_cpy ::= src_begin;
	i : u64 mut := 0;

	sign : s64 mut := 1;
	if(deref(src_begin) == '-')
	{
		sign = -1;
		src_begin = src_begin # 1;
		i = i + 1;
	}

	base : s64 mut := 10;
	ch : u8 mut;
	if(deref(src_begin) == '0')
	{
		src_begin = src_begin # 1;
		ch = deref(src_begin);
		if(ch == 'x')
		{
			base = 16;
			src_begin = src_begin # 1;
			i = i + 2;
		}
		if(ch == 'b')
		{
			base = 2;
			src_begin = src_begin # 1;
			i = i + 2;
		}
	}

	ival : s64 mut := 0;
	fval : f64 mut := 0;

	digit_val : s64 mut := 0;
	frac_div : f64 mut := 1.0;

	is_integral : bool mut := true;
	while(i < len)
	{
		ch = deref(begin_cpy # i);
		if(ch == '.')
		{
			is_integral = false;
		}
		if(isdigit(ch))
		{
			digit_val = (ch - '0')@_;
		}
		if(ch >= 'a')
		{
			if(ch <= 'f')
			{
				digit_val = (10 + (ch - 'a'));
			}
		}
		if(ch >= 'A')
		{
			if(ch <= 'F')
			{
				digit_val = (10 + (ch - 'A'));
			}
		}

		if(digit_val >= base)
		{
			return zero;
		}

		if(is_integral)
		{
			ival = ((ival * base) + digit_val);
		}
		if(!is_integral)
		{
			if(isdigit(ch))
			{
				frac_div = (frac_div / (base@f64));
				fval = (fval + ((digit_val@f64) * frac_div));
			}
		}

		i = i + 1;
	}

	if(is_integral)
	{
		return ival * sign;
	}
	return (fval + (ival@f64) * (sign@f64))@s64;
};
